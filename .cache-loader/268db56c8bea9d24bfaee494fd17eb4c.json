{"remainingRequest":"/Users/zhangtengjin/Desktop/byai/topology/node_modules/thread-loader/dist/cjs.js??ref--6-oneOf-1-1!/Users/zhangtengjin/Desktop/byai/topology/node_modules/babel-loader/lib/index.js??ref--6-oneOf-1-2!/Users/zhangtengjin/Desktop/byai/topology/node_modules/eslint-loader/index.js??ref--5-0!/Users/zhangtengjin/Desktop/byai/topology/src/lib/utils/tree.ts","dependencies":[{"path":"/Users/zhangtengjin/Desktop/byai/topology/src/lib/utils/tree.ts","mtime":1647506177154},{"path":"/Users/zhangtengjin/Desktop/byai/topology/package.json","mtime":1647506605470},{"path":"/Users/zhangtengjin/Desktop/byai/topology/node_modules/cache-loader/dist/cjs.js","mtime":1645756501487},{"path":"/Users/zhangtengjin/Desktop/byai/topology/node_modules/thread-loader/dist/cjs.js","mtime":1645756504722},{"path":"/Users/zhangtengjin/Desktop/byai/topology/node_modules/babel-loader/lib/index.js","mtime":1641784542889},{"path":"/Users/zhangtengjin/Desktop/byai/topology/node_modules/eslint-loader/index.js","mtime":1643179601592}],"contextDependencies":[],"result":["import _toConsumableArray from\"/Users/zhangtengjin/Desktop/byai/topology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/Users/zhangtengjin/Desktop/byai/topology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _defineProperty from\"/Users/zhangtengjin/Desktop/byai/topology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Users/zhangtengjin/Desktop/byai/topology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";import _ from'lodash';import{createHashFromObjectArray}from'.';/** 只含有单个root节点 */export var onlyOneRoot=function onlyOneRoot(data){var lines=data.lines,nodes=data.nodes;if(nodes.length<=1){return true;}var lineHashByEnd=lines.reduce(function(pre,cur){return _objectSpread({},pre,_defineProperty({},cur.end,cur));},{});return nodes.filter(function(item){return!lineHashByEnd[item.id];}).length===1;};/** 单个父节点 */export var onlyOneParent=function onlyOneParent(data){var lines=data.lines;var lineEndHash={};for(var i=0;i<lines.length;i+=1){var _lines$i=lines[i],start=_lines$i.start,end=_lines$i.end;var parent=start.split('-')[0];if(!lineEndHash[end]){lineEndHash[end]=parent;}else if(lineEndHash[end]!==parent){return false;}}return true;};/** 判断树是否有环 */export var hasRing=function hasRing(data){var flagHash={};var findRing=function findRing(node){var id=\"\".concat(node.id);if(!flagHash[id]){flagHash[id]=node;if(Array.isArray(node.childrenList)){for(var i=0;i<node.childrenList.length;i+=1){if(findRing(node.childrenList[i])){return true;}}return false;}return false;}return true;};return findRing(data);};export var processTree=function processTree(root,process){if(Array.isArray(root.childrenList)){// eslint-disable-next-line no-param-reassign\nroot.childrenList=root.childrenList.map(function(children){return processTree(children,process);});}return process(root);};/** 将数据转化为树结构 */export var convertToTree=function convertToTree(_ref,process){var nodes=_ref.nodes,lines=_ref.lines;var nodeHash=createHashFromObjectArray(nodes,'id');var lineEndHash=createHashFromObjectArray(lines,'end');var relationShipHash=lines.reduce(function(pre,cur){var relationHash=pre.relationHash,childrenListHash=pre.childrenListHash;var _cur$start$split=cur.start.split('-'),_cur$start$split2=_slicedToArray(_cur$start$split,2),parent=_cur$start$split2[0],anchor=_cur$start$split2[1];if(!Array.isArray(childrenListHash[parent])){childrenListHash[parent]=[];}if(!relationHash[cur.end]){relationHash[cur.end]={parent:parent,anchors:[]};}var relation=_objectSpread({},relationHash[cur.end],{anchors:[].concat(_toConsumableArray(relationHash[cur.end].anchors),[anchor])});var childrenList=_.uniq([].concat(_toConsumableArray(childrenListHash[parent]),[cur.end]));return{relationHash:_objectSpread({},relationHash,_defineProperty({},cur.end,relation)),childrenListHash:_objectSpread({},childrenListHash,_defineProperty({},parent,childrenList))};},{relationHash:{},childrenListHash:{}});nodes.forEach(function(item){var childrenListHash=relationShipHash.childrenListHash,relationHash=relationShipHash.relationHash;if(Array.isArray(childrenListHash[\"\".concat(item.id)])){// eslint-disable-next-line no-param-reassign\nitem.childrenList=childrenListHash[\"\".concat(item.id)].map(function(nodeId){nodeHash[nodeId].anchors=relationHash[nodeId].anchors;nodeHash[nodeId].parent=relationHash[nodeId].parent;return nodeHash[nodeId];});}});var root=nodes.find(function(item){return!lineEndHash[\"\".concat(item.id)];});if(!root){return null;}if(process){root=processTree(root,process);}return root;};",{"version":3,"sources":["/Users/zhangtengjin/Desktop/byai/topology/src/lib/utils/tree.ts"],"names":["_","createHashFromObjectArray","onlyOneRoot","data","lines","nodes","length","lineHashByEnd","reduce","pre","cur","end","filter","item","id","onlyOneParent","lineEndHash","i","start","parent","split","hasRing","flagHash","findRing","node","Array","isArray","childrenList","processTree","root","process","map","children","convertToTree","nodeHash","relationShipHash","relationHash","childrenListHash","anchor","anchors","relation","uniq","forEach","nodeId","find"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport { ITopologyNode, ITopologyData, ITopologyLine } from '../declare';\nimport { createHashFromObjectArray } from '.';\n\n/** 只含有单个root节点 */\nexport const onlyOneRoot = (data: ITopologyData) => {\n    const { lines, nodes } = data;\n    if (nodes.length <= 1) {\n        return true;\n    }\n    const lineHashByEnd = lines.reduce((pre, cur) => ({ ...pre, [cur.end]: cur }), {}) as { [id: string]: ITopologyLine };\n    return nodes.filter(item => !lineHashByEnd[item.id]).length === 1;\n};\n\n/** 单个父节点 */\nexport const onlyOneParent = (data: ITopologyData) => {\n    const { lines } = data;\n    const lineEndHash = {} as { [id: string]: string };\n    for (let i = 0; i < lines.length; i += 1) {\n        const { start, end } = lines[i];\n        const parent = start.split('-')[0];\n        if (!lineEndHash[end]) {\n            lineEndHash[end] = parent;\n        } else if (lineEndHash[end] !== parent) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/** 判断树是否有环 */\nexport const hasRing = (data: ITopologyNode) => {\n    const flagHash = {} as { [id: string]: ITopologyNode };\n    const findRing = (node: ITopologyNode) => {\n        const id = `${node.id}`;\n        if (!flagHash[id]) {\n            flagHash[id] = node;\n            if (Array.isArray(node.childrenList)) {\n                for (let i = 0; i < node.childrenList.length; i += 1) {\n                    if (findRing(node.childrenList[i])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            return false;\n        }\n        return true;\n    };\n    return findRing(data);\n};\n\nexport const processTree = (root: ITopologyNode, process: (dataF: ITopologyNode) => ITopologyNode) => {\n    if (Array.isArray(root.childrenList)) {\n        // eslint-disable-next-line no-param-reassign\n        root.childrenList = root.childrenList.map(\n            (children: ITopologyNode) => processTree(children, process),\n        );\n    }\n    return process(root);\n};\n\ninterface RelationHash {\n    relationHash: { [id: string]: { parent: string; anchors: string[] } };\n    childrenListHash: { [id: string]: string[] };\n}\n\n/** 将数据转化为树结构 */\nexport const convertToTree = (\n    { nodes, lines }: ITopologyData,\n    process?: (data: ITopologyNode) => ITopologyNode,\n) => {\n    const nodeHash = createHashFromObjectArray(nodes, 'id') as { [id: string]: ITopologyNode };\n    const lineEndHash = createHashFromObjectArray(lines, 'end') as { [id: string]: ITopologyLine };\n    const relationShipHash = lines.reduce((pre: RelationHash, cur) => {\n        const { relationHash, childrenListHash } = pre;\n        const [parent, anchor] = cur.start.split('-');\n        if (!Array.isArray(childrenListHash[parent])) {\n            childrenListHash[parent] = [];\n        }\n        if (!relationHash[cur.end]) {\n            relationHash[cur.end] = { parent, anchors: [] };\n        }\n        const relation = {\n            ...relationHash[cur.end],\n            anchors: [...relationHash[cur.end].anchors, anchor],\n        };\n        const childrenList = _.uniq([...childrenListHash[parent], cur.end]);\n        return {\n            relationHash: { ...relationHash, [cur.end]: relation },\n            childrenListHash: { ...childrenListHash, [parent]: childrenList },\n        };\n    }, { relationHash: {}, childrenListHash: {} }) as RelationHash;\n\n    nodes.forEach((item) => {\n        const { childrenListHash, relationHash } = relationShipHash;\n        if (Array.isArray(childrenListHash[`${item.id}`])) {\n            // eslint-disable-next-line no-param-reassign\n            item.childrenList = childrenListHash[`${item.id}`].map((nodeId: string) => {\n                nodeHash[nodeId].anchors = relationHash[nodeId].anchors;\n                nodeHash[nodeId].parent = relationHash[nodeId].parent;\n                return nodeHash[nodeId];\n            });\n        }\n    });\n    let root = nodes.find(item => !lineEndHash[`${item.id}`]);\n    if (!root) {\n        return null;\n    }\n    if (process) {\n        root = processTree(root, process);\n    }\n    return root;\n};\n"]}]}